import 'zx/globals';

import _ from "lodash";
import { core, parse } from "@interslavic/steen-utils";

import razumlivost from '../dist/index.js';

import { LANGS } from "./utils/constants.mjs";
import * as csv from './utils/csv.mjs';
import { loadDictionary } from "./utils/hunspell.mjs";

const flavorizers = razumlivost.flavorizers.slow;
const quickFlavorizers = razumlivost.flavorizers.quick;

await main(process.argv[3]);

async function main(targetLang) {
  const rawWords = await csv.parseFile(`__fixtures__/words.csv`);

  const words = rawWords.map((word) => {
    const result = {};
    result.raw = word;
    result.id = word.id;
    result.partOfSpeech = parse.partOfSpeech(word.partOfSpeech);
    result.genesis = word.genesis ? parse.genesis(word.genesis) : undefined;

    const isPhrase = word.partOfSpeech.name === 'phrase';
    for (const lang of ['isv', ...LANGS]) {
      if (CYRL_LANGS.includes(lang)) {
        word[lang] = cyrillizer.flavorize(word[lang])[0];
      }

      result[lang] = parse.synset(word[lang] || '', { isPhrase })
    }

    return result;
  });

  await fs.mkdirp('__fixtures__/analysis');

  for (const lang of (targetLang ? [targetLang] : LANGS)) {
    console.log(`Analysing language: ${chalk.yellow(lang)}`);

    const analysisPath = `__fixtures__/analysis/${lang}.csv`;
    const records = fs.existsSync(analysisPath)
      ? toPlainMap(await csv.parseFile(analysisPath))
      : {};

    let counter = 0;
    const hunspell = await loadDictionary(lang);
    for (const word of words) {
      counter++;
      if (counter % 1000 === 0) {
        console.log(counter, 'of', words.length);
        await csv.writeFile(analysisPath, _.sortBy(records, r => r.id));
      }

      const results = flavorizers[lang].compareDebug(word, word.isv, word[lang]);
      const good = results.filter(match => match.distance.percent <= 13).map(match => match.target.value);
      const mediocre = results.filter(match => match.distance.percent > 13 && match.distance.percent < 35).map(match => match.target.value);
      const goodAndMediocre = [...good, ...mediocre];
      const quickFlavorization = quickFlavorizers[lang].flavorize(word, word.isv);
      /** @type {string[]} */
      let maybeHelperWords = hunspell && good.length === 0
        ? quickFlavorization.map(v => v.replace(/\p{Letter}+/gu, (vf) => {
          if (hunspell.spellSync(vf)) return vf;
          const suggestions = hunspell.suggestSync(vf);
          return suggestions.length > 0 ? suggestions[0] : vf;
        }))
        : [];
      maybeHelperWords = _.uniq(maybeHelperWords);

      const newRecord = {
        id: +word.id,
        isv: word.raw.isv,
        translationOriginal: word.raw[lang],
        translationCorrection: '',
        translationMatch: parse.synset(`!${goodAndMediocre.join(', ')}`, { isPhrase: false }),
        helperWords: parse.synset(`!${maybeHelperWords.join(', ')}`, { isPhrase: false }),
        falseFriends: new core.Synset({ autogenerated: good.length ? false : true }),
        flavorization: parse.synset(`!${quickFlavorization.join(', ')}`, { isPhrase: false }),
      };

      newRecord.translationMatch.meta.autogenerated = good.length === 0;
      if (_.intersection(goodAndMediocre, quickFlavorization).length) {
        newRecord.flavorization.meta.autogenerated = false;
        newRecord.translationMatch.meta.autogenerated = false;
        newRecord.helperWords.meta.autogenerated = false;
        newRecord.helperWords.groups = [];
      }

      for (const key of ['translationMatch', 'helperWords', 'falseFriends', 'flavorization']) {
        newRecord[key] = newRecord[key].toString();
      }

      records[newRecord.id] = newRecord;
    }

    const sorted = _.sortBy(records, r => r.id);
    await csv.writeFile(analysisPath, sorted);
  }
}

function toPlainMap(rows) {
  return rows.reduce((map, row) => {
    map[row.id] = row;
    return map;
  }, {});
}
