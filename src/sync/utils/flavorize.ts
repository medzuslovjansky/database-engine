import {
  FlavorizationRecord,
  Raw,
  TranslationRecord,
} from '../../types/tables';
import { NATURAL_LANGUAGES } from '../constants';
import { leftJoin } from './sql';
import { core, parse } from '@interslavic/steen-utils';
import { flavorizers, Odometer } from '../../index';

export type FlavorizeStepOptions = {
  /**
   * Language columns to flavorize
   */
  langs: Array<keyof typeof NATURAL_LANGUAGES>;
  /**
   * Updates even if the flavorization is not auto-generated.
   * @default false
   */
  forceUpdate?: boolean;
};

export function* flavorize(
  translations: Raw<TranslationRecord>[],
  flavorizations: Raw<FlavorizationRecord>[],
  options: FlavorizeStepOptions,
): IterableIterator<Raw<FlavorizationRecord>> {
  const extractId = (r: Record<string, unknown>) => r.id as string;
  for (const results of leftJoin(extractId, translations, flavorizations)) {
    const t = results[0];
    const rf = results[1];
    const f: Raw<FlavorizationRecord> = {
      id: t.id,
      isv: t.isv,
      addition: t.addition,
      partOfSpeech: t.partOfSpeech,
      frequency: t.frequency,
      en: t.en,
      ru: rf?.ru || '!',
      be: rf?.be || '!',
      uk: rf?.uk || '!',
      pl: rf?.pl || '!',
      cs: rf?.cs || '!',
      sk: rf?.sk || '!',
      bg: rf?.bg || '!',
      mk: rf?.mk || '!',
      sr: rf?.sr || '!',
      hr: rf?.hr || '!',
      sl: rf?.sl || '!',
    };

    const odometer = new Odometer<core.Synset, core.Lemma>({
      ignoreCase: true,
      ignoreNonLetters: true,
      ignoreDiacritics: true,
      extractItems: (synset) => synset.lemmas(),
      extractValue: (lemma) => lemma.value.replace(/(\p{Letter})\1+/gu, '$1'),
    });

    const isPhrase = parse.partOfSpeech(t.partOfSpeech).name === 'phrase';
    const isv = parse.synset(t.isv, { isPhrase });
    for (const lang of options.langs) {
      const existing = parse.synset(f[lang], { isPhrase });

      if (existing.meta.autogenerated || options.forceUpdate) {
        const translation = parse.synset(t[lang], { isPhrase });
        if (!translation.empty) {
          const flavorized = flavorizers.quick[lang].flavorize(t, isv);
          const similar = odometer.compare(flavorized, translation);
          if (similar.editingDistance === 0) {
            const newValue = similar.result.clone();
            newValue.annotations.splice(0, Infinity);
            f[lang] = newValue.toString();
            console.log(`${t.id} ${lang} ${t[lang]} ${f[lang]}`);
          }
        }
      }
    }

    yield f;
  }
}
